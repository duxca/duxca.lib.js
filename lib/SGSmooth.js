// Generated by CoffeeScript 1.10.0
(function() {
  var SGSmooth;

  SGSmooth = (function() {
    var workerScript;

    function SGSmooth(nth_degree_polynomial, radius) {
      this.nth_degree_polynomial = nth_degree_polynomial;
      this.radius = radius;
      this.currentWorker = 0;
      this.workers = [1].map(function(i) {
        return new ServerWorker(workerScript, [this.nth_degree_polynomial, this.radius]);
      });
    }

    SGSmooth.prototype.process = function(f32arr) {
      var worker;
      worker = this.workers[this.currentWorker++];
      if (this.workers.length === this.currentWorker) {
        this.currentWorker = 0;
      }
      return new Promise(function(resolve, reject) {
        return worker.request("calc", f32arr, resolve);
      });
    };

    workerScript = function(p, m) {
      importScripts("https://cdnjs.cloudflare.com/ajax/libs/mathjs/1.1.1/math.min.js");
      return self.on("calc", function(f32arr, reply) {
        var A, B, C, X, Y, derivatives, j, k, l, n, point, ref, results, results1, y;
        y = f32arr;
        point = 0;
        derivatives = (function() {
          results = [];
          for (var j = 0; 0 <= p ? j <= p : j >= p; 0 <= p ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this).map(function() {
          return new Float32Array(y.length);
        });
        while (y.length > point + 2 * m + 1) {
          X = (function() {
            results1 = [];
            for (var l = 0; 0 <= p ? l <= p : l >= p; 0 <= p ? l++ : l--){ results1.push(l); }
            return results1;
          }).apply(this).map(function(_, ik) {
            var l, ref, results1;
            return (function() {
              results1 = [];
              for (var l = ref = -m; ref <= m ? l <= m : l >= m; ref <= m ? l++ : l--){ results1.push(l); }
              return results1;
            }).apply(this).map(function(im) {
              return Math.pow(im, ik);
            });
          });
          Y = Array.prototype.slice.call(y, point, point + 2 * m + 1);
          C = math.inv(math.multiply(X, math.transpose(X)));
          B = math.multiply(C, X);
          A = math.multiply(B, Y);
          for (k = n = 0, ref = p; 0 <= ref ? n <= ref : n >= ref; k = 0 <= ref ? ++n : --n) {
            derivatives[k][point + m + 1] = math.factorial(k) * A[k];
          }
          point += 1;
        }
        return reply(derivatives, derivatives.map(function(arg) {
          var buffer;
          buffer = arg.buffer;
          return buffer;
        }));
      });
    };

    return SGSmooth;

  })();

  module.exports = SGSmooth;

}).call(this);
