// Generated by CoffeeScript 1.12.1
(function() {
  var $, CanvasRender, Chord, Newton, OSC, Point, RecordBuffer, SDM, Signal, Statictics, TEST_INPUT_MYSELF, abuf, actx, addEventListeners, beep, chord, fetchChord, fetchPulse, fetchStream, isRecording, osc, period, processor, pulse, pulseStartTime, pulseStopTime, recbuf, recur, testDetect9;

  CanvasRender = require("./ts/CanvasRender");

  Signal = require("./ts/Signal");

  RecordBuffer = require("./ts/RecordBuffer");

  OSC = require("./ts/OSC");

  Statictics = require("./ts/Statictics");

  Chord = require("./ts/Chord").Chord;

  Newton = require("./ts/Newton");

  $ = require("jquery");

  Point = Newton.Point;

  SDM = Newton.SDM;

  period = 0;

  self.$ = $;

  self.jQuery = $;

  chord = new Chord({
    host: "https://www.duxca.com/",
    port: 9000
  });

  chord.debug = false;

  actx = new AudioContext();

  osc = new OSC(actx);

  isRecording = false;

  processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1);

  recbuf = new RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);

  TEST_INPUT_MYSELF = false;

  abuf = null;

  pulseStartTime = {};

  pulseStopTime = {};

  pulse = null;

  fetchStream = function() {
    return new Promise(function(resolbe, reject) {
      return navigator.getUserMedia({
        video: false,
        audio: true
      }, resolbe, reject);
    }).then(function(stream) {
      var source;
      source = actx.createMediaStreamSource(stream);
      if (TEST_INPUT_MYSELF) {
        source.connect(processor);
      }
      processor.connect(actx.destination);
      return processor.addEventListener("audioprocess", function(ev) {
        if (isRecording) {
          return recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
        }
      });
    });
  };

  fetchChord = function(rootNodeId) {
    if (typeof rootNodeId === "string") {
      return chord.join(rootNodeId);
    } else {
      return chord.create();
    }
  };

  fetchPulse = function() {
    return osc.createBarkerCodedChirp(13, 8).then(function(_pulse) {
      var render;
      pulse = _pulse;
      render = new CanvasRender(128, 128);
      render.cnv.width = 1024;
      render.drawSignal(pulse, true, true);
      console.log("length", pulse.length, "sec", pulse.length / actx.sampleRate);
      document.body.appendChild(render.element);
      return abuf = osc.createAudioBufferFromArrayBuffer(pulse, actx.sampleRate);
    });
  };

  beep = function(abuf) {
    var anode;
    anode = osc.createAudioNodeFromAudioBuffer(abuf);
    anode.connect(TEST_INPUT_MYSELF ? processor : actx.destination);
    return anode.start(actx.currentTime);
  };

  addEventListeners = function() {
    chord.on("ping", function(token, cb) {
      return cb(token);
    });
    chord.on("recStart", function(token, cb) {
      isRecording = true;
      return cb(token);
    });
    chord.on("pulseStart", function(token, cb) {
      var id;
      id = token.payload.data;
      pulseStartTime[id] = actx.currentTime;
      return cb(token);
    });
    chord.on("pulseBeep", function(token, cb) {
      var id;
      id = token.payload.data;
      if (chord.peer.id !== id) {
        return cb(token);
      } else {
        beep(abuf);
        return setTimeout((function() {
          return cb(token);
        }), pulse.length / actx.sampleRate * 1000);
      }
    });
    chord.on("pulseStop", function(token, cb) {
      var id;
      id = token.payload.data;
      pulseStopTime[id] = actx.currentTime;
      return cb(token);
    });
    chord.on("recStop", function(token, cb) {
      isRecording = false;
      return cb(token);
    });
    chord.on("collect", function(token, cb) {
      return cb(token);
    });
    chord.on("distribute", function(token, cb) {
      return cb(token);
    });
    return chord.on("play", function(token, cb) {
      return cb(token);
    });
  };

  recur = function() {
    console.group("period");
    return chord.request("ping").then(function(token) {
      return chord.request("recStart", null, token.route);
    }).then(function(token) {
      return token.payload.addressee.reduce((function(prm, id) {
        return prm.then(function(token) {
          return chord.request("pulseStart", id, token.payload.addressee);
        }).then(function(token) {
          return chord.request("pulseBeep", id, token.payload.addressee);
        }).then(function(token) {
          return chord.request("pulseStop", id, token.payload.addressee);
        });
      }), Promise.resolve(token));
    }).then(function(token) {
      return chord.request("recStop", null, token.route);
    }).then(function(token) {
      return chord.request("collect", null, token.route);
    }).then(function(token) {
      return chord.request("distribute", null, token.route);
    }).then(function(token) {
      console.log("period finish", period++);
      console.groupEnd();
      return setTimeout(recur, 5000);
    });
  };

  testDetect9 = function(rootNodeId) {
    return Promise.all([fetchStream(), fetchPulse(), fetchChord(rootNodeId)]).then(function(arg) {
      var _, __, chord;
      _ = arg[0], __ = arg[1], chord = arg[2];
      addEventListeners();
      console.info(chord.peer.id);
      if (rootNodeId == null) {
        return recur({
          chord: chord
        });
      }
    });
  };

  exports.testDetect9 = testDetect9;

}).call(this);
