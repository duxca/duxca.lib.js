// Generated by CoffeeScript 1.12.2
(function() {
  var cnv, ctx, input, least_square, noized, noizing, output, strokeArray, x;

  console.clear();

  strokeArray = function(cnv, ctx, ary, flagX, flagY) {
    var i, k, ref, zoomX, zoomY;
    if (flagX == null) {
      flagX = false;
    }
    if (flagY == null) {
      flagY = false;
    }
    zoomX = !flagX ? 1 : cnv.width / ary.length;
    zoomY = !flagY ? 1 : cnv.height / Math.max.apply(null, ary);
    ctx.beginPath();
    ctx.moveTo(0, cnv.height - ary[0] * zoomY);
    for (i = k = 1, ref = ary.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
      ctx.lineTo(zoomX * i, cnv.height - ary[i] * zoomY);
    }
    return ctx.stroke();
  };

  noizing = function(x) {
    return x + (Math.random() - 0.5) * 0.5;
  };

  input = (function() {
    var k, results;
    results = [];
    for (x = k = 0; k <= 20; x = k += 0.05) {
      results.push([x, Math.cos(x)]);
    }
    return results;
  })();

  noized = input.map(function(arg) {
    var x, y;
    x = arg[0], y = arg[1];
    return [x, noizing(y)];
  });

  least_square = function(vec) {
    var A, B, C, X, Y, f, k, l, m, n, p, point, result, results, results1, results2, y;
    x = vec.map(function(pt) {
      return pt[0];
    });
    y = vec.map(function(pt) {
      return pt[1];
    });
    m = (x.length - 1) / 4 | 0;
    p = 10;
    point = 0;
    result = (function() {
      results = [];
      for (var k = 0; 0 <= m ? k <= m : k >= m; 0 <= m ? k++ : k--){ results.push(k); }
      return results;
    }).apply(this).map(function() {
      return 0;
    });
    while (y.length > point + 2 * m + 1) {
      X = (function() {
        results1 = [];
        for (var l = 0; 0 <= p ? l <= p : l >= p; 0 <= p ? l++ : l--){ results1.push(l); }
        return results1;
      }).apply(this).map(function(_, ik) {
        var l, ref, results1;
        return (function() {
          results1 = [];
          for (var l = ref = -m; ref <= m ? l <= m : l >= m; ref <= m ? l++ : l--){ results1.push(l); }
          return results1;
        }).apply(this).map(function(im) {
          return Math.pow(im, ik);
        });
      });
      Y = y.slice(point, point + 2 * m + 1);
      point += 1;
      C = math.inv(math.multiply(X, math.transpose(X)));
      B = math.multiply(C, X);
      A = math.multiply(B, Y);
      f = function(x) {
        return A.reduce((function(sum, a, j) {
          return sum + a * Math.pow(x, j);
        }), 0);
      };
      result.push([x[m + 1], A[0]]);
    }
    return result.concat((function() {
      results2 = [];
      for (var n = 0; 0 <= m ? n <= m : n >= m; 0 <= m ? n++ : n--){ results2.push(n); }
      return results2;
    }).apply(this).map(function() {
      return 0;
    }));
  };

  output = least_square(noized);

  cnv = document.createElement("canvas");

  cnv.width = 320;

  cnv.height = 320;

  ctx = cnv.getContext("2d");

  document.body.appendChild(cnv);

  ctx.strokeStyle = "red";

  strokeArray(cnv, ctx, input.map(function(arg) {
    var x, y;
    x = arg[0], y = arg[1];
    return y * 100 + 160;
  }), true);

  ctx.strokeStyle = "green";

  strokeArray(cnv, ctx, noized.map(function(arg) {
    var x, y;
    x = arg[0], y = arg[1];
    return y * 100 + 160;
  }), true);

  ctx.strokeStyle = "blue";

  strokeArray(cnv, ctx, output.map(function(arg) {
    var x, y;
    x = arg[0], y = arg[1];
    return y * 100 + 160;
  }), true);

}).call(this);
