// Generated by CoffeeScript 1.12.2
(function() {
  var LSystem, main, nStepLSystem, turtle;

  main = function() {
    var code, opt, rules, turtleRules;
    code = "F";
    rules = [["F", "F[+F-F-F]F[--F+F+F]"]];
    turtleRules = [
      [
        "F", {
          "command": "forward",
          "args": [10]
        }
      ], [
        "+", {
          "command": "turn",
          "args": [15]
        }
      ], [
        "-", {
          "command": "turn",
          "args": [-15]
        }
      ], [
        "[", {
          "command": "push",
          "args": []
        }
      ], [
        "]", {
          "command": "pop",
          "args": []
        }
      ]
    ];
    opt = {
      "headding": -Math.PI / 2,
      "zoom": 2,
      "speed": 10,
      "offsetX": 0,
      "offsetY": 300,
      "height": 600
    };
    return turtle(nStepLSystem(code, rules, 3), turtleRules, opt, function() {});
  };

  LSystem = function(code, rules) {
    var _rule, head, result;
    result = "";
    while (code.length > 0) {
      head = code[0];
      code = code.slice(1);
      _rule = rules.filter(function(rule) {
        return rule[0] === head;
      });
      if (_rule.length > 0) {
        result += _rule[0][1];
      } else {
        result += head;
      }
    }
    return result;
  };

  nStepLSystem = function(code, rules, step) {
    while (step--) {
      code = LSystem(code, rules);
    }
    return code;
  };

  turtle = function(code, rules, opt, callback) {
    var ctx, headding, offsetX, offsetY, recur, skipCount, speed, stack, vct, zoom;
    cnv.width = opt.width || 400;
    cnv.height = opt.height || 400;
    ctx = cnv.getContext("2d");
    headding = opt.headding || 0;
    zoom = opt.zoom || 5;
    speed = opt.speed || 5;
    offsetX = opt.offsetX || 0;
    offsetY = opt.offsetY || 0;
    vct = [cnv.width / 2 + offsetX, cnv.height / 2 + offsetY];
    stack = [];
    skipCount = 0;
    ctx.moveTo(vct[0], vct[1]);
    return (recur = function() {
      var _rule, args, command, head, ref;
      if (code.length > 0) {
        head = code[0];
        code = code.slice(1);
        _rule = rules.filter(function(rule) {
          return rule[0] === head;
        });
        if (_rule.length > 0) {
          command = _rule[0][1].command;
          args = _rule[0][1].args;
          switch (command) {
            case "forward":
              vct[0] += Math.cos(headding) * Number(args[0]) * zoom;
              vct[1] += Math.sin(headding) * Number(args[0]) * zoom;
              break;
            case "turn":
              headding += Math.PI * Number(args[0]) / 180;
              break;
            case "push":
              stack.push({
                "position": vct.slice(),
                "headding": headding
              });
              break;
            case "pop":
              ref = stack.pop(), vct = ref["position"], headding = ref["headding"];
              ctx.moveTo(vct[0], vct[1]);
          }
        }
        ctx.lineTo(vct[0], vct[1]);
        ctx.stroke();
        if (skipCount++ > speed) {
          skipCount = 0;
          return requestAnimationFrame(recur);
        } else {
          return recur();
        }
      } else {
        return setTimeout(callback, 1000);
      }
    })();
  };

  main();

}).call(this);
