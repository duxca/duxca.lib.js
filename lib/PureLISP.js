// Generated by CoffeeScript 1.12.2
(function() {
  var ENV, __eval, _eval, apply, atom, list, parse, root, sexpr, special,
    slice = [].slice;

  ENV = {
    T: "T",
    nil: "nil",
    atom: function(env, arg) {
      var a;
      a = arg[0];
      if (a != null) {
        return [env, a instanceof Array ? "nil" : "T"];
      } else {
        throw "TypeError: arguments less";
      }
    },
    eq: function(env, arg) {
      var a, b;
      a = arg[0], b = arg[1];
      if ((a != null) && (b != null)) {
        return [env, a === b ? "T" : "nil"];
      } else {
        throw "TypeError: arguments less";
      }
    },
    car: function(env, arg) {
      var a;
      a = arg[0];
      if (a instanceof Array) {
        return [env, a[0]];
      } else {
        throw "TypeError: " + a + " is not list";
      }
    },
    cdr: function(env, arg) {
      var a;
      a = arg[0];
      if (a instanceof Array) {
        return [env, a[1]];
      } else {
        throw "TypeError: " + a + " is not list";
      }
    },
    cons: function(env, arg) {
      var a, b;
      a = arg[0], b = arg[1];
      if ((a != null) && (b != null)) {
        return [env, [a, b]];
      } else {
        throw "TypeError: arguments less";
      }
    }
  };

  special = {
    cond: function(env, arg) {
      var a, b, c, ref, val;
      a = arg[0], b = arg[1], c = arg[2];
      if ((a != null) && (b != null) && (c != null)) {
        if ((ref = __eval(env, a), env = ref[0], val = ref[1], ref)[1]) {
          return __eval(env, b);
        } else {
          return __eval(env, c);
        }
      } else {
        throw "TypeError: bad cond expression";
      }
    },
    define: function(env, arg) {
      var a, b, ref, val;
      a = arg[0], b = arg[1];
      if ((a != null) && (b != null)) {
        ref = __eval(env, b), env = ref[0], val = ref[1];
        env[a] = val;
        return [env, val];
      } else {
        throw "TypeError: bad define expression";
      }
    },
    quote: function(env, arg) {
      var a;
      a = arg[0];
      return [env, a];
    },
    lambda: function(env, arg) {
      var args, expr, lmd;
      args = arg[0], expr = arg[1];
      if (args instanceof Array && (expr != null)) {
        lmd = function(env, operands) {
          var closure, ref, val;
          closure = Object.create(env);
          args.forEach(function(key, i) {
            return closure[key] = operands[i];
          });
          ref = __eval(closure, expr), closure = ref[0], val = ref[1];
          return [env, val];
        };
        return [env, lmd];
      } else {
        throw "TypeError: bad lambda expression";
      }
    }
  };

  apply = function(env, exprs) {
    var head, operands, operator, ref, tail;
    head = exprs[0], tail = 2 <= exprs.length ? slice.call(exprs, 1) : [];
    if (special[head] != null) {
      return special[head](env, tail);
    } else {
      ref = __eval(env, head), env = ref[0], operator = ref[1];
      if (operator instanceof Function) {
        operands = tail.map(function(expr) {
          var ref1, val;
          ref1 = __eval(env, expr), env = ref1[0], val = ref1[1];
          return val;
        });
        return operator(env, operands);
      } else {
        throw "TypeError: " + operator + " is not function";
      }
    }
  };

  __eval = function(env, expr) {
    if (expr instanceof Array) {
      return apply(env, expr);
    } else {
      if (env[expr] != null) {
        return [env, env[expr]];
      } else {
        throw "ReferenceError: " + expr + " is not defined";
      }
    }
  };

  parse = function(input) {
    var tokens;
    tokens = input.split("(").join(" ( ").split(")").join(" ) ").trim().split(/\s+/);
    return root(tokens, []);
  };

  root = function(tokens, exprs) {
    var _tokens, expr, ref;
    if (tokens.length === 0) {
      return exprs;
    } else {
      ref = sexpr(tokens), _tokens = ref[0], expr = ref[1];
      exprs.push(expr);
      return root(_tokens, exprs);
    }
  };

  sexpr = function(tokens) {
    if (tokens.length === 0) {
      throw "ParseError: unexpected EOF expected ( or atom";
    }
    if (tokens[0] === "(") {
      return list(tokens.slice(1), []);
    } else {
      return atom(tokens);
    }
  };

  list = function(tokens, exprs) {
    var _tokens, expr, ref;
    if (tokens.length === 0) {
      throw "ParseError: unexpected EOF expected ) or sexpr";
    }
    if (tokens[0] === ")") {
      return [tokens.slice(1), exprs];
    } else {
      ref = sexpr(tokens), _tokens = ref[0], expr = ref[1];
      exprs.push(expr);
      return list(_tokens, exprs);
    }
  };

  atom = function(tokens) {
    return [tokens.slice(1), tokens[0]];
  };

  _eval = function(input) {
    var env, err, exprs;
    try {
      exprs = parse(input);
      env = ENV;
      return exprs.map(function(expr) {
        var ref, val;
        ref = __eval(env, expr), env = ref[0], val = ref[1];
        return val;
      }).join("\n");
    } catch (error) {
      err = error;
      return err;
    }
  };

  (function() {
    var input, output, results;
    input = "";
    output = "";
    results = [];
    while (input = prompt(output, "")) {
      results.push(output = ">" + input + "\n" + _eval(input));
    }
    return results;
  })();

}).call(this);
