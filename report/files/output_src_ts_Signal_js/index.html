<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - output/src/ts/Signal.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>output/src/ts/Signal.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">164</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">95.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.66</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/// &lt;reference path=&quot;../../tsd/dsp/dsp.d.ts&quot; /&gt;
var duxca;
(function (duxca) {
    var lib;
    (function (lib) {
        var Signal;
        (function (Signal) {
            function normalize(arr, max_val) {
                if (max_val === void 0) { max_val = 1; }
                var min = duxca.lib.Statictics.findMin(arr)[0];
                var max = duxca.lib.Statictics.findMax(arr)[0];
                var _arr = new Float32Array(arr.length);
                for (var j = 0; j &lt; arr.length; j++) {
                    _arr[j] = (arr[j] - min) / (max - min) * max_val;
                }
                return _arr;
            }
            Signal.normalize = normalize;
            function correlation(signalA, signalB, sampleRate) {
                if (signalA.length !== signalB.length)
                    throw new Error(&quot;unmatch signal length A and B as &quot; + signalA.length + &quot; and &quot; + signalB.length);
                var _fft = new FFT(signalA.length, sampleRate);
                _fft.forward(signalA);
                //var a_spectrum = new Float32Array(fft.spectrum);
                var a_real = new Float32Array(_fft.real);
                var a_imag = new Float32Array(_fft.imag);
                _fft.forward(signalB);
                //var b_spectrum = new Float32Array(_fft.spectrum);
                var b_real = _fft.real; //new Float32Array(_fft.real);
                var b_imag = _fft.imag; //new Float32Array(_fft.imag);
                var cross_real = b_real; //new Float32Array(b_real.length);
                var cross_imag = b_imag; //new Float32Array(b_imag.length);
                for (var i = 0; i &lt; cross_real.length; i++) {
                    cross_real[i] = a_real[i] * b_real[i] / cross_real.length;
                    cross_imag[i] = a_imag[i] * b_imag[i] / cross_imag.length;
                }
                var inv_real = _fft.inverse(cross_real, cross_imag);
                for (var i = 0; i &lt; inv_real.length; i++) {
                    inv_real[i] = inv_real[i] / inv_real.length;
                }
                return inv_real;
            }
            Signal.correlation = correlation;
            function smartCorrelation(short, long, sampleRate) {
                for (var pow = 8; short.length + long.length &gt; Math.pow(2, pow); pow++)
                    ;
                var tmpA = new Float32Array(Math.pow(2, pow));
                var tmpB = new Float32Array(Math.pow(2, pow));
                tmpA.set(short, 0);
                tmpB.set(long, 0);
                var corrsec = correlation(tmpA, tmpB, sampleRate);
                return corrsec.subarray(0, long.length &gt; short.length ? long.length : short.length);
            }
            Signal.smartCorrelation = smartCorrelation;
            function overwarpCorr(short, long) {
                for (var pow = 8; short.length &gt; Math.pow(2, pow); pow++)
                    ; // ajasting power of two for FFT
                var resized_short = new Float32Array(Math.pow(2, pow)); // for overwrap adding way correlation
                resized_short.set(short, 0);
                var buffer = new Float32Array(Math.pow(2, pow)); // for overwrap adding way correlation
                var correlation = new Float32Array(long.length);
                var windowsize = Math.pow(2, pow - 1);
                //console.log(long.length, windowsize, resized_short.length, buffer.length, correlation.length)
                for (var i = 0; long.length - (i + windowsize) &gt;= resized_short.length; i += windowsize) {
                    buffer.set(long.subarray(i, i + windowsize), 0);
                    var corr = Signal.correlation(buffer, resized_short);
                    for (var j = 0; j &lt; corr.length; j++) {
                        correlation[i + j] = corr[j];
                    }
                }
                return correlation;
            }
            Signal.overwarpCorr = overwarpCorr;
            function autocorr(arr) {
                return crosscorr(arr, arr);
            }
            Signal.autocorr = autocorr;
            function crosscorr(arrA, arrB) {
                function _autocorr(j) {
                    var sum = 0;
                    for (var i = 0; i &lt; arrA.length - j; i++)
                        sum += arrA[i] * arrB[i + j];
                    return sum;
                }
                return arrA.map(function (v, j) { return _autocorr(j); });
            }
            Signal.crosscorr = crosscorr;
            function fft(signal, sampleRate) {
                if (sampleRate === void 0) { sampleRate = 44100; }
                var _fft = new FFT(signal.length, sampleRate);
                _fft.forward(signal);
                return [_fft.real, _fft.imag, _fft.spectrum];
            }
            Signal.fft = fft;
            function createChirpSignal(pulse_length, downchirp) {
                if (downchirp === void 0) { downchirp = false; }
                var flag = downchirp ? 1 : -1;
                var pulse_real = new Float32Array(pulse_length);
                var pulse_imag = new Float32Array(pulse_length);
                for (var i = 0; i &lt; pulse_length / 2; i++) {
                    pulse_real[i] = Math.cos(Math.PI * i * (i / pulse_length + 1 / 2));
                    pulse_imag[i] = flag * Math.sin(Math.PI * i * (i / pulse_length + 1 / 2));
                }
                for (var i = pulse_length / 2 + 1; i &lt; pulse_length; i++) {
                    pulse_real[i] = pulse_real[pulse_length - i];
                    pulse_imag[i] = -pulse_imag[pulse_length - i];
                }
                var _fft = new FFT(pulse_length, 44100);
                var inv_real = _fft.inverse(pulse_real, pulse_imag);
                return inv_real;
            }
            Signal.createChirpSignal = createChirpSignal;
            function createBarkerCode(n) {
                switch (n) {
                    case 1: return [1];
                    case 2: return [1, -1];
                    case 3: return [1, 1, -1];
                    case 4: return [1, 1, -1, 1];
                    case 5: return [1, 1, 1, -1, 1];
                    case 7: return [1, 1, 1, -1, -1, 1, -1];
                    case 11: return [1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1];
                    case 13: return [1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1];
                    default: throw new Error(&quot;cannot make barker code outer 2, 3, 4, 5, 7, 11, 13&quot;);
                }
            }
            Signal.createBarkerCode = createBarkerCode;
            function createComplementaryCode(pow2) {
                var a = [1, 1];
                var b = [1, -1];
                function compress(a, b) {
                    return [a.concat(b), a.concat(b.map(function (x) { return -x; }))];
                }
                while (pow2--) {
                    _a = compress(a, b), a = _a[0], b = _a[1];
                }
                return [a, b];
                var _a;
            }
            Signal.createComplementaryCode = createComplementaryCode;
            function createCodedChirp(code, bitWithBinaryPower) {
                if (bitWithBinaryPower === void 0) { bitWithBinaryPower = 10; }
                var bitwidth = Math.pow(2, bitWithBinaryPower);
                var up_chirp = duxca.lib.Signal.createChirpSignal(bitwidth);
                var down_chirp = new Float32Array(up_chirp);
                for (var i = 0; i &lt; down_chirp.length; i++) {
                    down_chirp[i] *= -1;
                }
                var pulse = new Float32Array(bitwidth / 2 * code.length + bitwidth / 2);
                for (var i = 0; i &lt; code.length; i++) {
                    var tmp = (code[i] === 1) ? up_chirp : down_chirp;
                    for (var j = 0; j &lt; tmp.length; j++) {
                        pulse[i * bitwidth / 2 + j] += tmp[j];
                    }
                }
                return pulse;
            }
            Signal.createCodedChirp = createCodedChirp;
            function createBarkerCodedChirp(barkerCodeN, bitWithBinaryPower) {
                if (bitWithBinaryPower === void 0) { bitWithBinaryPower = 10; }
                return createCodedChirp(createBarkerCode(barkerCodeN));
            }
            Signal.createBarkerCodedChirp = createBarkerCodedChirp;
        })(Signal = lib.Signal || (lib.Signal = {}));
    })(lib = duxca.lib || (duxca.lib = {}));
})(duxca || (duxca = {}));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
