<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - output/src/ts/Sandbox2.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>output/src/ts/Sandbox2.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">640</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">140.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.89</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/// &lt;reference path=&quot;../../typings/webrtc/MediaStream.d.ts&quot;/&gt;
/// &lt;reference path=&quot;../../typings/bluebird/bluebird.d.ts&quot;/&gt;
/// &lt;reference path=&quot;../../tsd/console.snapshot/console.snapshot.d.ts&quot;/&gt;
/// &lt;reference path=&quot;../../tsd/MediaStreamAudioSourceNode/MediaStreamAudioSourceNode.d.ts&quot;/&gt;
var duxca;
(function (duxca) {
    var lib;
    (function (lib) {
        var Sandbox2;
        (function (Sandbox2) {
            navigator.getUserMedia = (navigator.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia);
            function _(id) {
                var data = [
                    { id: &quot;a&quot;, data: { a: 0, b: 1, c: 2 } },
                    { id: &quot;b&quot;, data: { a: 1, b: 0, c: 1 } },
                    { id: &quot;c&quot;, data: { a: 2, b: 1, c: 0 } }
                ];
                for (var i = 0; i &lt; 3; i++)
                    for (var j = i + 1; j &lt; 3; j++)
                        console.log(i, j, i + &quot;[&quot; + i + &quot;~&quot; + j + &quot;]&quot;);
            }
            Sandbox2._ = _;
            function testAutoDetect3(id) {
                var TEST_INPUT_MYSELF = false;
                var actx = new AudioContext();
                var codeA = duxca.lib.Signal.createBarkerCode(13);
                var pulseA = createPulse(codeA, 6);
                console.log(actx.sampleRate, pulseA.length, pulseA.length / actx.sampleRate);
                var render = new duxca.lib.CanvasRender(128, 128);
                render.cnv.width = pulseA.length;
                render.drawSignal(pulseA, true, true);
                console.screenshot(render.element);
                var processor = actx.createScriptProcessor(Math.pow(2, 12), 1, 1); // between Math.pow(2,8) and Math.pow(2,14).
                var recbuf = new lib.RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);
                var isRecording = false;
                var stdscoreResult = null;
                var pulseReady = {};
                var pulseFinish = {};
                var results = {};
                Promise.resolve()
                    .then(setupRecording)
                    .then(setupChord)
                    .then(function (chd) {
                    console.log(chd.peer.id);
                    if (typeof id !== &quot;string&quot;) {
                        // master node
                        setTimeout(function recur() {
                            chd.request(&quot;ping&quot;)
                                .then(function (token) {
                                console.log(token.payload.event, token.route);
                                var member = token.route;
                                return chd.request(&quot;startRec&quot;, { member: member })
                                    .then(function (token) {
                                    return token.route.reduce(function (prm, id) {
                                        return prm
                                            .then(function (token) { return chd.request(&quot;pulseStart&quot;, { member: member, id: id }); })
                                            .then(function (token) { return chd.request(&quot;pulseBeep&quot;, { member: member, id: id }); })
                                            .then(function (token) { return chd.request(&quot;pulseStop&quot;, { member: member, id: id }); });
                                    }, Promise.resolve(token));
                                })
                                    .then(function (token) { return chd.request(&quot;stopRec&quot;, { member: member, id: id }); })
                                    .then(function (token) { return chd.request(&quot;calc&quot;, { member: member, id: id }); })
                                    .then(function (token) { return chd.request(&quot;collect&quot;, { member: member, data: [] }); })
                                    .then(function (token) {
                                    console.log(token.payload.event, token.route, token.payload.data);
                                    var data = token.payload.data.data;
                                    data.forEach(function (_a, i) {
                                        var id1 = _a.id;
                                        data.forEach(function (_a, j) {
                                            var id2 = _a.id;
                                            if (!Array.isArray(results[id1 + &quot;-&quot; + id2]))
                                                results[id1 + &quot;-&quot; + id2] = [];
                                            if (results[id1 + &quot;-&quot; + id2].length &gt; 20)
                                                results[id1 + &quot;-&quot; + id2].shift();
                                            var tmp = Math.abs(Math.abs(data[i].stdscoreResult[id2]) - Math.abs(data[j].stdscoreResult[id1]));
                                            if (isFinite(tmp))
                                                results[id1 + &quot;-&quot; + id2].push(tmp);
                                            console.log(&quot;__RES__&quot;, id1 + &quot;-&quot; + id2, duxca.lib.Statictics.median(results[id1 + &quot;-&quot; + id2]) * 170);
                                        });
                                    });
                                    setTimeout(function () { return recur(); }, 1000);
                                });
                            })
                                .catch(function (err) { return console.error(err); });
                        }, 1000);
                    }
                    console.log(&quot;ready.&quot;);
                });
                function setupChord() {
                    var chd = new duxca.lib.Chord();
                    var osc = new duxca.lib.OSC(actx);
                    var abufA = osc.createAudioBufferFromArrayBuffer(pulseA, 44100);
                    chd.debug = false;
                    chd.on(&quot;ping&quot;, function (token, cb) {
                        console.log(token.payload.event);
                        cb(token);
                    });
                    chd.on(&quot;startRec&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event);
                        isRecording = true;
                        cb(token);
                    });
                    chd.on(&quot;pulseStart&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        pulseReady[token.payload.data.id] = actx.currentTime;
                        cb(token);
                    });
                    chd.on(&quot;pulseBeep&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        if (token.payload.data.id !== chd.peer.id)
                            return cb(token);
                        var anodeA = osc.createAudioNodeFromAudioBuffer(abufA);
                        anodeA.connect(TEST_INPUT_MYSELF ? processor : actx.destination);
                        anodeA.start(actx.currentTime + 0.05);
                        setTimeout(function () { return cb(token); }, 300);
                    });
                    chd.on(&quot;pulseStop&quot;, function (token, cb) {
                        console.log(token.payload.data.member, token.payload.data.member.indexOf(chd.peer.id));
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        pulseFinish[token.payload.data.id] = actx.currentTime;
                        cb(token);
                    });
                    chd.on(&quot;stopRec&quot;, function (token, cb) {
                        console.log(token.payload.data.member, token.payload.data.member.indexOf(chd.peer.id));
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event);
                        isRecording = false;
                        cb(token);
                    });
                    chd.on(&quot;calc&quot;, function (token, cb) {
                        console.log(token.payload.data.member, token.payload.data.member.indexOf(chd.peer.id));
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event);
                        stdscoreResult = null;
                        cb(token);
                        setTimeout(function () { return stdscoreResult = calc(chd.peer.id); }, 100);
                    });
                    chd.on(&quot;collect&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        (function recur() {
                            if (stdscoreResult !== null) {
                                token.payload.data.data.push({ id: chd.peer.id, stdscoreResult: stdscoreResult });
                                cb(token);
                            }
                            else
                                setTimeout(recur, 0);
                        })();
                    });
                    return (typeof id === &quot;string&quot;) ? chd.join(id) : chd.create();
                }
                function setupRecording() {
                    return new Promise(function (resolbe, reject) { return navigator.getUserMedia({ video: false, audio: true }, resolbe, reject); })
                        .then(function (stream) {
                        var source = actx.createMediaStreamSource(stream);
                        !TEST_INPUT_MYSELF &amp;&amp; source.connect(processor);
                        processor.connect(actx.destination);
                        processor.addEventListener(&quot;audioprocess&quot;, function handler(ev) {
                            if (isRecording) {
                                recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
                            }
                        });
                    });
                }
                function createPulse(code, length) {
                    var chirp = duxca.lib.Signal.createCodedChirp(code, length);
                    for (var pow = 0; chirp.length &gt; Math.pow(2, pow); pow++)
                        ; // ajasting power of two for FFT
                    var pulse = new Float32Array(Math.pow(2, pow));
                    pulse.set(chirp, 0);
                    return pulse;
                }
                function calcCorr(pulse, rawdata) {
                    var windowsize = pulse.length;
                    var resized_pulse = new Float32Array(windowsize * 2); // for overwrap adding way correlation
                    resized_pulse.set(pulse, 0);
                    var buffer = new Float32Array(windowsize * 2); // for overwrap adding way correlation
                    var correlation = new Float32Array(rawdata.length);
                    for (var i = 0; rawdata.length - (i + windowsize) &gt;= resized_pulse.length; i += windowsize) {
                        buffer.set(rawdata.subarray(i, i + windowsize), 0);
                        var corr = duxca.lib.Signal.correlation(buffer, resized_pulse);
                        for (var j = 0; j &lt; corr.length; j++) {
                            correlation[i + j] = corr[j];
                        }
                    }
                    return correlation;
                }
                function calcStdscore(correlation) {
                    var _correlation = duxca.lib.Signal.normalize(correlation, 100);
                    var ave = duxca.lib.Statictics.average(_correlation);
                    var vari = duxca.lib.Statictics.variance(_correlation);
                    var stdscores = new Float32Array(_correlation.length);
                    for (var i = 0; i &lt; _correlation.length; i++) {
                        stdscores[i] = 10 * (_correlation[i] - ave) / vari + 50;
                    }
                    return stdscores;
                }
                function calc(myId) {
                    console.log(recbuf);
                    var rawdata = recbuf.merge();
                    var sampleTimes = recbuf.sampleTimes;
                    recbuf.clear();
                    console.group(&quot;calc correlation&quot;);
                    console.time(&quot;calc correlation&quot;);
                    var correlationA = calcCorr(pulseA, rawdata);
                    console.timeEnd(&quot;calc correlation&quot;);
                    console.groupEnd();
                    console.group(&quot;calc stdscore&quot;);
                    console.time(&quot;calc stdscore&quot;);
                    var stdscoresA = calcStdscore(correlationA);
                    console.timeEnd(&quot;calc stdscore&quot;);
                    console.groupEnd();
                    console.group(&quot;calc cycle&quot;);
                    console.time(&quot;calc cycle&quot;);
                    var recStartTime = sampleTimes[0] - recbuf.bufferSize / recbuf.sampleRate;
                    var recStopTime = sampleTimes[sampleTimes.length - 1];
                    var results = {};
                    var render = new duxca.lib.CanvasRender(1024, 32);
                    Object.keys(pulseReady).forEach(function (id) {
                        var startTime = pulseReady[id];
                        var stopTime = pulseFinish[id];
                        var startPtr = (startTime - recStartTime) * recbuf.sampleRate;
                        var stopPtr = (stopTime - recStartTime) * recbuf.sampleRate;
                        var sectionA = correlationA.subarray(startPtr, stopPtr);
                        console.log(id, &quot;recStartTime&quot;, recStartTime, &quot;recStopTime&quot;, recStopTime, &quot;startTime&quot;, startTime, &quot;stopTime&quot;, stopTime, &quot;startPtr&quot;, startPtr, &quot;stopPtr&quot;, stopPtr, &quot;length&quot;, sectionA.length);
                        var stdsectionA = calcStdscore(sectionA);
                        var _a = duxca.lib.Statictics.findMax(stdsectionA), max_score = _a[0], max_offset = _a[1];
                        for (var i = 0; i &lt; 1024; i++) {
                            if (stdsectionA[max_offset - 2048 / 2 + i] &gt; 70) {
                                var offset = max_offset - 2048 / 2 + i;
                                break;
                            }
                        }
                        console.log(id, &quot;offset&quot;, offset, &quot;max_offset&quot;, max_offset, &quot;max_score&quot;, stdsectionA[offset], &quot;globalOffset&quot;, startPtr + offset);
                        results[id] = startPtr + offset;
                        render.clear();
                        render.ctx.strokeStyle = &quot;black&quot;;
                        render.drawSignal(sectionA, true, true);
                        render.ctx.strokeStyle = &quot;red&quot;;
                        render.drawColLine(offset * 1024 / sectionA.length);
                        console.log(id, &quot;section&quot;);
                        console.screenshot(render.cnv);
                    });
                    var render1 = new duxca.lib.CanvasRender(1024, 32);
                    var render2 = new duxca.lib.CanvasRender(1024, 32);
                    var render3 = new duxca.lib.CanvasRender(1024, 32);
                    render1.drawSignal(stdscoresA, true, true);
                    render2.drawSignal(rawdata, true, true);
                    var tmp = new Float32Array(rawdata.length);
                    Object.keys(results).forEach(function (id) { tmp.set(pulseA, results[id]); });
                    render3.drawSignal(tmp, true, true);
                    Object.keys(results).forEach(function (id) {
                        var startTime = pulseReady[id];
                        var stopTime = pulseFinish[id];
                        var startPtr = (startTime - recStartTime) * recbuf.sampleRate;
                        var stopPtr = (stopTime - recStartTime) * recbuf.sampleRate;
                        render1.ctx.strokeStyle = &quot;blue&quot;;
                        render2.ctx.strokeStyle = &quot;blue&quot;;
                        render3.ctx.strokeStyle = &quot;blue&quot;;
                        render1.drawColLine(startPtr * 1024 / stdscoresA.length);
                        render1.drawColLine(stopPtr * 1024 / stdscoresA.length);
                        render2.drawColLine(startPtr * 1024 / stdscoresA.length);
                        render2.drawColLine(stopPtr * 1024 / stdscoresA.length);
                        render3.drawColLine(startPtr * 1024 / stdscoresA.length);
                        render3.drawColLine(stopPtr * 1024 / stdscoresA.length);
                        render1.ctx.strokeStyle = &quot;red&quot;;
                        render2.ctx.strokeStyle = &quot;red&quot;;
                        render3.ctx.strokeStyle = &quot;red&quot;;
                        render1.drawColLine(results[id] * 1024 / stdscoresA.length);
                        render2.drawColLine(results[id] * 1024 / stdscoresA.length);
                        render3.drawColLine(results[id] * 1024 / stdscoresA.length);
                    });
                    console.log(&quot;stdscores&quot;);
                    console.screenshot(render1.cnv);
                    console.log(&quot;rawdata&quot;);
                    console.screenshot(render2.cnv);
                    console.log(&quot;sim&quot;);
                    console.screenshot(render3.cnv);
                    console.log(&quot;results&quot;, results);
                    var _results = {};
                    Object.keys(results).forEach(function (id) {
                        _results[id] = (results[id] - results[myId]) / recbuf.sampleRate;
                    });
                    console.log(&quot;results&quot;, _results);
                    console.timeEnd(&quot;calc cycle&quot;);
                    console.groupEnd();
                    console.group(&quot;show spectrogram&quot;);
                    console.time(&quot;show spectrogram&quot;);
                    var render = new duxca.lib.CanvasRender(128, 128);
                    var windowsize = Math.pow(2, 8); // spectrgram height
                    var slidewidth = Math.pow(2, 5); // spectrgram width rate
                    var sampleRate = recbuf.sampleRate;
                    console.log(&quot;sampleRate:&quot;, sampleRate, &quot;\n&quot;, &quot;windowsize:&quot;, windowsize, &quot;\n&quot;, &quot;slidewidth:&quot;, slidewidth, &quot;\n&quot;, &quot;windowsize(ms):&quot;, windowsize / sampleRate * 1000, &quot;\n&quot;, &quot;slidewidth(ms):&quot;, slidewidth / sampleRate * 1000, &quot;\n&quot;);
                    var spectrums = [];
                    for (var ptr = 0; ptr + windowsize &lt; rawdata.length; ptr += slidewidth) {
                        var buffer = rawdata.subarray(ptr, ptr + windowsize);
                        if (buffer.length !== windowsize)
                            break;
                        var spectrum = duxca.lib.Signal.fft(buffer, sampleRate)[2];
                        for (var i = 0; i &lt; spectrum.length; i++) {
                            spectrum[i] = spectrum[i] * 20000;
                        }
                        spectrums.push(spectrum);
                    }
                    console.log(&quot;ptr&quot;, 0 + &quot;-&quot; + (ptr - 1) + &quot;/&quot; + rawdata.length, &quot;ms&quot;, 0 / sampleRate * 1000 + &quot;-&quot; + (ptr - 1) / sampleRate * 1000 + &quot;/&quot; + rawdata.length * 1000 / sampleRate, spectrums.length + &quot;x&quot; + spectrums[0].length);
                    render.cnv.width = spectrums.length;
                    render.cnv.height = spectrums[0].length;
                    render.drawSpectrogram(spectrums);
                    console.screenshot(render.cnv);
                    console.timeEnd(&quot;show spectrogram&quot;);
                    console.groupEnd();
                    return _results;
                }
            }
            Sandbox2.testAutoDetect3 = testAutoDetect3;
            function testAutoDetect2(id) {
                var PULSE_INTERVAL_SEC = 0.5;
                var PULSE_REFRAIN = 1;
                var CUTOFF_STANDARDSCORE = 100;
                var TEST_INPUT_MYSELF = false;
                var actx = new AudioContext();
                var codeA = duxca.lib.Signal.createBarkerCode(1);
                var pulseA = createPulse(codeA, 12);
                console.log(actx.sampleRate, pulseA.length, pulseA.length / actx.sampleRate);
                var render = new duxca.lib.CanvasRender(128, 128);
                render.cnv.width = pulseA.length;
                render.drawSignal(pulseA, true, true);
                console.screenshot(render.element);
                var processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1); // between Math.pow(2,8) and Math.pow(2,14).
                var recbuf = new lib.RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);
                var isRecording = false;
                var stdscoreResult = null;
                var pulseReady = {};
                var pulseFinish = {};
                Promise.resolve()
                    .then(setupRecording)
                    .then(setupChord)
                    .then(function (chd) {
                    console.log(chd.peer.id);
                    if (typeof id !== &quot;string&quot;) {
                        // master node
                        setTimeout(function recur() {
                            chd.request(&quot;ping&quot;)
                                .then(function (token) {
                                console.log(token.payload.event, token.route);
                                return chd.request(&quot;startRec&quot;, { member: token.route });
                            })
                                .then(function (token) {
                                console.log(token.payload.event, token.route);
                                return token.route.reduce(function (prm, id) {
                                    return prm
                                        .then(function (token) { return chd.request(&quot;pulseStart&quot;, { member: token.route, id: id }); })
                                        .then(function (token) { return chd.request(&quot;pulseBeep&quot;, { member: token.route, id: id }); })
                                        .then(function (token) { return chd.request(&quot;pulseStop&quot;, { member: token.route, id: id }); });
                                }, Promise.resolve(token));
                            })
                                .then(function (token) { return chd.request(&quot;stopRec&quot;, { member: token.route, id: id }); })
                                .then(function (token) { return chd.request(&quot;calc&quot;, { member: token.route, id: id }); })
                                .then(function (token) { return chd.request(&quot;collect&quot;, { member: token.route, data: [] }); })
                                .then(function (token) {
                                console.log(token.payload.event, token.route, token.payload.data);
                                var data = token.payload.data.data;
                                data.forEach(function (_a, i) {
                                    var id1 = _a.id;
                                    data.forEach(function (_a, j) {
                                        var id2 = _a.id;
                                        console.log(id1, id2, Math.abs(Math.abs(data[i].stdscoreResult[id2]) - Math.abs(data[j].stdscoreResult[id1])));
                                    });
                                });
                                setTimeout(function () { return recur(); }, 1000);
                            })
                                .catch(function (err) { return console.error(err); });
                        }, 1000);
                    }
                    console.log(&quot;ready.&quot;);
                });
                function setupChord() {
                    var chd = new duxca.lib.Chord();
                    var osc = new duxca.lib.OSC(actx);
                    var abufA = osc.createAudioBufferFromArrayBuffer(pulseA, actx.sampleRate);
                    chd.debug = false;
                    chd.on(&quot;ping&quot;, function (token, cb) {
                        console.log(token.payload.event);
                        cb(token);
                    });
                    chd.on(&quot;startRec&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event);
                        isRecording = true;
                        cb(token);
                    });
                    chd.on(&quot;pulseStart&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        pulseReady[token.payload.data.id] = actx.currentTime;
                        setTimeout(function () { return cb(token); }, 0);
                    });
                    chd.on(&quot;pulseBeep&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        if (token.payload.data.id !== chd.peer.id)
                            return cb(token);
                        var offsetTime = actx.currentTime + 0.1;
                        for (var i = 0; i &lt; PULSE_REFRAIN; i++) {
                            var anode = osc.createAudioNodeFromAudioBuffer(abufA);
                            anode.connect(TEST_INPUT_MYSELF ? processor : actx.destination);
                            anode.start(offsetTime + PULSE_INTERVAL_SEC * i);
                        }
                        setTimeout(function () { return cb(token); }, PULSE_REFRAIN * PULSE_INTERVAL_SEC * 1000 + 100);
                    });
                    chd.on(&quot;pulseStop&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        pulseFinish[token.payload.data.id] = actx.currentTime;
                        setTimeout(function () { return cb(token); }, 0);
                    });
                    chd.on(&quot;stopRec&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event);
                        isRecording = false;
                        cb(token);
                    });
                    chd.on(&quot;calc&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event);
                        cb(token);
                        stdscoreResult = null;
                        setTimeout(function () { return stdscoreResult = calc(chd.peer.id); }, 100);
                    });
                    chd.on(&quot;collect&quot;, function (token, cb) {
                        if (token.payload.data.member.indexOf(chd.peer.id) &lt; 0)
                            return cb(token);
                        console.log(token.payload.event, token.payload.data);
                        (function recur() {
                            if (stdscoreResult !== null) {
                                token.payload.data.data.push({ id: chd.peer.id, stdscoreResult: stdscoreResult });
                                cb(token);
                            }
                            else
                                setTimeout(recur, 500);
                        })();
                    });
                    return (typeof id === &quot;string&quot;) ? chd.join(id) : chd.create();
                }
                function setupRecording() {
                    return new Promise(function (resolbe, reject) { return navigator.getUserMedia({ video: false, audio: true }, resolbe, reject); })
                        .then(function (stream) {
                        var source = actx.createMediaStreamSource(stream);
                        !TEST_INPUT_MYSELF &amp;&amp; source.connect(processor);
                        processor.connect(actx.destination);
                        processor.addEventListener(&quot;audioprocess&quot;, function handler(ev) {
                            if (isRecording) {
                                recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
                            }
                        });
                    });
                }
                function createPulse(code, length) {
                    var chirp = duxca.lib.Signal.createCodedChirp(code, length);
                    for (var pow = 0; chirp.length &gt; Math.pow(2, pow); pow++)
                        ; // ajasting power of two for FFT
                    var pulse = new Float32Array(Math.pow(2, pow));
                    pulse.set(chirp, 0);
                    return pulse;
                }
                function calcCorr(pulse, rawdata) {
                    var windowsize = pulse.length;
                    var resized_pulse = new Float32Array(windowsize * 2); // for overwrap adding way correlation
                    resized_pulse.set(pulse, 0);
                    var buffer = new Float32Array(windowsize * 2); // for overwrap adding way correlation
                    var correlation = new Float32Array(rawdata.length);
                    for (var i = 0; rawdata.length - (i + windowsize) &gt;= resized_pulse.length; i += windowsize) {
                        buffer.set(rawdata.subarray(i, i + windowsize), 0);
                        var corr = duxca.lib.Signal.correlation(buffer, resized_pulse);
                        for (var j = 0; j &lt; corr.length; j++) {
                            correlation[i + j] = corr[j];
                        }
                    }
                    return correlation;
                }
                function calcStdscore(correlation) {
                    var _correlation = duxca.lib.Signal.normalize(correlation, 100);
                    var ave = duxca.lib.Statictics.average(_correlation);
                    var vari = duxca.lib.Statictics.variance(_correlation);
                    console.log(&quot;ave:&quot;, ave, &quot;\n&quot;, &quot;med:&quot;, duxca.lib.Statictics.median(_correlation), &quot;\n&quot;, &quot;var:&quot;, vari, &quot;\n&quot;);
                    var stdscores = new Float32Array(_correlation.length);
                    for (var i = 0; i &lt; _correlation.length; i++) {
                        stdscores[i] = 10 * (_correlation[i] - ave) / vari + 50;
                    }
                    return stdscores;
                }
                function calc(myId) {
                    var rawdata = recbuf.merge();
                    var sampleTimes = recbuf.sampleTimes;
                    recbuf.clear();
                    console.group(&quot;calc correlation&quot;);
                    console.time(&quot;calc correlation&quot;);
                    var correlationA = calcCorr(pulseA, rawdata);
                    var correlation = new Float32Array(correlationA.length);
                    for (var i = 0; i &lt; correlation.length; i++) {
                        correlation[i] = correlationA[i];
                    }
                    console.timeEnd(&quot;calc correlation&quot;);
                    console.groupEnd();
                    console.group(&quot;calc stdscore&quot;);
                    console.time(&quot;calc stdscore&quot;);
                    var stdscores = calcStdscore(correlation);
                    console.timeEnd(&quot;calc stdscore&quot;);
                    console.groupEnd();
                    console.group(&quot;calc cycle&quot;);
                    console.time(&quot;calc cycle&quot;);
                    var results = {};
                    Object.keys(pulseReady).forEach(function (id) {
                        console.log(id);
                        console.log(recbuf.bufferSize / recbuf.sampleRate);
                        var recStartTime = sampleTimes[0] - recbuf.bufferSize / recbuf.sampleRate;
                        var recStopTime = sampleTimes[sampleTimes.length - 1];
                        var startTime = pulseReady[id];
                        var stopTime = pulseFinish[id];
                        var startPtr = (startTime - recStartTime) * recbuf.sampleRate;
                        var stopPtr = (stopTime - recStartTime) * recbuf.sampleRate;
                        console.log(&quot;startPtr&quot;, startPtr, &quot;stopPtr&quot;, stopPtr);
                        var section = stdscores.subarray(startPtr, stopPtr);
                        var _section = duxca.lib.Signal.normalize(section, 128); // _** for draw
                        var splitsize = PULSE_INTERVAL_SEC * recbuf.sampleRate;
                        console.log(&quot;splitsize&quot;, splitsize);
                        var sumarr = new Float32Array(splitsize);
                        var offsets = [];
                        var render = new duxca.lib.CanvasRender(128, 128);
                        for (var i = 0; i &lt; _section.length; i += splitsize) {
                            var part = section.subarray(i, i + splitsize);
                            var _part = _section.subarray(i, i + splitsize);
                            var _a = duxca.lib.Statictics.findMax(part), max_score = _a[0], offset = _a[1];
                            if (max_score &gt; CUTOFF_STANDARDSCORE) {
                                offsets.push(offset);
                            }
                            console.log(&quot;part&quot;, &quot;total_offset&quot;, i + offset, &quot;local_offset&quot;, offset, &quot;stdscore&quot;, max_score);
                            render.cnv.width = 1024; //_part.length;
                            render.ctx.strokeStyle = &quot;black&quot;;
                            render.drawSignal(_part, true, false);
                            render.ctx.strokeStyle = max_score &gt; CUTOFF_STANDARDSCORE ? &quot;red&quot; : &quot;blue&quot;;
                            render.drawColLine(offset * 1024 / sumarr.length);
                            console.screenshot(render.cnv);
                            if (sumarr.length === part.length) {
                                for (var j = 0; j &lt; part.length; j++) {
                                    sumarr[j] += part[j];
                                }
                            }
                        }
                        console.log(&quot;phaseshifts&quot;, offsets);
                        var ave = duxca.lib.Statictics.average(offsets);
                        var med = duxca.lib.Statictics.median(offsets);
                        var mode = duxca.lib.Statictics.mode(offsets);
                        var _b = duxca.lib.Statictics.findMax(sumarr), max_score = _b[0], offset = _b[1];
                        console.log(&quot;min&quot;, duxca.lib.Statictics.findMin(offsets)[0], &quot;\n&quot;, &quot;max&quot;, duxca.lib.Statictics.findMax(offsets)[0], &quot;\n&quot;, &quot;ave&quot;, ave, &quot;red&quot;, &quot;\n&quot;, &quot;med&quot;, med, &quot;green&quot;, &quot;\n&quot;, &quot;mode&quot;, mode, &quot;blue&quot;, &quot;\n&quot;, &quot;sum&quot;, offset, &quot;yellow&quot;, &quot;\n&quot;, &quot;stdev&quot;, duxca.lib.Statictics.stdev(offsets));
                        console.log(&quot;sum&quot;, &quot;stdscore&quot;, max_score, &quot;global_offset&quot;, startPtr + offset);
                        // global_offset this is bad. because startPtr is time of pulseStart event.
                        // i need pulseBeep event time. so this program does not work.
                        results[id] = startPtr + offset;
                        render.cnv.width = 1024; //sumarr.length;
                        render.ctx.strokeStyle = &quot;gray&quot;;
                        render.drawSignal(sumarr, true, true);
                        render.ctx.strokeStyle = &quot;red&quot;;
                        render.drawColLine(ave * 1024 / sumarr.length);
                        render.ctx.strokeStyle = &quot;green&quot;;
                        render.drawColLine(med * 1024 / sumarr.length);
                        render.ctx.strokeStyle = &quot;blue&quot;;
                        render.drawColLine(mode * 1024 / sumarr.length);
                        render.ctx.strokeStyle = &quot;yellow&quot;;
                        render.drawColLine(offset * 1024 / sumarr.length);
                        console.screenshot(render.cnv);
                        console.timeEnd(&quot;calc cycle&quot;);
                        console.groupEnd();
                    });
                    console.group(&quot;show spectrogram&quot;);
                    console.time(&quot;show spectrogram&quot;);
                    var render = new duxca.lib.CanvasRender(128, 128);
                    var windowsize = Math.pow(2, 8); // spectrgram height
                    var slidewidth = Math.pow(2, 5); // spectrgram width rate
                    var sampleRate = recbuf.sampleRate;
                    console.log(&quot;sampleRate:&quot;, sampleRate, &quot;\n&quot;, &quot;windowsize:&quot;, windowsize, &quot;\n&quot;, &quot;slidewidth:&quot;, slidewidth, &quot;\n&quot;, &quot;windowsize(ms):&quot;, windowsize / sampleRate * 1000, &quot;\n&quot;, &quot;slidewidth(ms):&quot;, slidewidth / sampleRate * 1000, &quot;\n&quot;);
                    var spectrums = [];
                    var ptr = 0;
                    var lstptr = 0;
                    recur();
                    function recur() {
                        if (ptr + windowsize &gt; rawdata.length) {
                            console.timeEnd(&quot;show spectrogram&quot;);
                            console.groupEnd();
                            return;
                        }
                        for (var j = 0; j &lt; PULSE_INTERVAL_SEC * sampleRate / slidewidth; j++) {
                            var buffer = rawdata.subarray(ptr, ptr + windowsize);
                            if (buffer.length !== windowsize)
                                break;
                            var spectrum = duxca.lib.Signal.fft(buffer, sampleRate)[2];
                            for (var i = 0; i &lt; spectrum.length; i++) {
                                spectrum[i] = spectrum[i] * 20000;
                            }
                            spectrums.push(spectrum);
                            ptr += slidewidth;
                        }
                        draw();
                        setTimeout(recur);
                    }
                    function draw() {
                        console.log(&quot;ptr&quot;, lstptr + &quot;-&quot; + (ptr - 1) + &quot;/&quot; + rawdata.length, &quot;ms&quot;, lstptr / sampleRate * 1000 + &quot;-&quot; + (ptr - 1) / sampleRate * 1000 + &quot;/&quot; + rawdata.length * 1000 / sampleRate, spectrums.length + &quot;x&quot; + spectrums[0].length);
                        render.cnv.width = spectrums.length;
                        render.cnv.height = spectrums[0].length;
                        render.drawSpectrogram(spectrums);
                        console.screenshot(render.cnv);
                        spectrums = [];
                        lstptr = ptr;
                    }
                    var _results = results;
                    Object.keys(results).forEach(function (id) {
                        _results[id] = results[myId] - results[id];
                    });
                    return _results;
                }
            }
            Sandbox2.testAutoDetect2 = testAutoDetect2;
        })(Sandbox2 = lib.Sandbox2 || (lib.Sandbox2 = {}));
    })(lib = duxca.lib || (duxca.lib = {}));
})(duxca || (duxca = {}));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
