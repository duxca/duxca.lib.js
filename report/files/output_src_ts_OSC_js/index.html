<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - output/src/ts/OSC.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>output/src/ts/OSC.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">139</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.31</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var duxca;
(function (duxca) {
    var lib;
    (function (lib) {
        var OSC = (function () {
            function OSC(actx) {
                this.actx = actx;
            }
            OSC.prototype.tone = function (freq, startTime, duration) {
                var osc = this.actx.createOscillator();
                osc.start(startTime);
                osc.stop(startTime + duration);
                var gain = this.actx.createGain();
                gain.gain.value = 0;
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(1, startTime + 0.01);
                gain.gain.setValueAtTime(1, startTime + duration - 0.01);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);
                osc.connect(gain);
                return gain;
            };
            OSC.prototype.createAudioBufferFromArrayBuffer = function (arr, sampleRate) {
                var abuf = this.actx.createBuffer(1, arr.length, sampleRate);
                var buf = abuf.getChannelData(0);
                buf.set(arr);
                return abuf;
            };
            OSC.prototype.createAudioNodeFromAudioBuffer = function (abuf) {
                var asrc = this.actx.createBufferSource();
                asrc.buffer = abuf;
                return asrc;
            };
            OSC.prototype.createBarkerCodedChirp = function (barkerCodeN, powN) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    var actx = _this.actx;
                    var osc = _this;
                    var code = duxca.lib.Signal.createBarkerCode(barkerCodeN);
                    var chirp = duxca.lib.Signal.createCodedChirp(code, powN);
                    var abuf = osc.createAudioBufferFromArrayBuffer(chirp, 44100); // fix rate
                    var anode = osc.createAudioNodeFromAudioBuffer(abuf);
                    for (var pow = 8; chirp.length &gt; Math.pow(2, pow); pow++)
                        ; // ajasting power of two for FFT
                    var processor = actx.createScriptProcessor(Math.pow(2, pow), 1, 1); // between Math.pow(2,8) and Math.pow(2,14).
                    var recbuf = new lib.RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);
                    anode.start(actx.currentTime);
                    anode.connect(processor);
                    processor.connect(actx.destination);
                    processor.addEventListener(&quot;audioprocess&quot;, function handler(ev) {
                        processor.removeEventListener(&quot;audioprocess&quot;, handler);
                        processor.disconnect();
                        resolve(Promise.resolve(new Float32Array(ev.inputBuffer.getChannelData(0))));
                    });
                });
            };
            OSC.prototype.resampling = function (sig, pow, sampleRate) {
                var _this = this;
                if (pow === void 0) { pow = 14; }
                if (sampleRate === void 0) { sampleRate = 44100; }
                return new Promise(function (resolve, reject) {
                    var abuf = _this.createAudioBufferFromArrayBuffer(sig, sampleRate); // fix rate
                    var anode = _this.createAudioNodeFromAudioBuffer(abuf);
                    var processor = _this.actx.createScriptProcessor(Math.pow(2, pow), 1, 1); // between Math.pow(2,8) and Math.pow(2,14).
                    var recbuf = new lib.RecordBuffer(_this.actx.sampleRate, processor.bufferSize, processor.channelCount);
                    anode.start(_this.actx.currentTime);
                    anode.connect(processor);
                    processor.connect(_this.actx.destination);
                    var actx = _this.actx;
                    processor.addEventListener(&quot;audioprocess&quot;, function handler(ev) {
                        recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
                        if (recbuf.count * recbuf.bufferSize &gt; sig.length) {
                            processor.removeEventListener(&quot;audioprocess&quot;, handler);
                            processor.disconnect();
                            next();
                        }
                    });
                    function next() {
                        var rawdata = recbuf.merge();
                        recbuf.clear();
                        resolve(Promise.resolve(rawdata));
                    }
                });
            };
            OSC.prototype.inpulseResponce = function (TEST_INPUT_MYSELF) {
                var _this = this;
                if (TEST_INPUT_MYSELF === void 0) { TEST_INPUT_MYSELF = false; }
                var up = lib.Signal.createChirpSignal(Math.pow(2, 17), false);
                var down = lib.Signal.createChirpSignal(Math.pow(2, 17), true);
                //up = up.subarray(up.length*1/4|0, up.length*3/4|0);
                //down = up.subarray(up.length*1/4|0, up.length*3/4|0);
                new Promise(function (resolbe, reject) { return navigator.getUserMedia({ video: false, audio: true }, resolbe, reject); })
                    .then(function (stream) {
                    var source = _this.actx.createMediaStreamSource(stream);
                    var processor = _this.actx.createScriptProcessor(Math.pow(2, 14), 1, 1); // between Math.pow(2,8) and Math.pow(2,14).
                    var abuf = _this.createAudioBufferFromArrayBuffer(up, _this.actx.sampleRate); // fix rate
                    var anode = _this.createAudioNodeFromAudioBuffer(abuf);
                    anode.start(_this.actx.currentTime + 0);
                    anode.connect(TEST_INPUT_MYSELF ? processor : _this.actx.destination);
                    !TEST_INPUT_MYSELF &amp;&amp; source.connect(processor);
                    processor.connect(_this.actx.destination);
                    var recbuf = new lib.RecordBuffer(_this.actx.sampleRate, processor.bufferSize, 1);
                    var actx = _this.actx;
                    processor.addEventListener(&quot;audioprocess&quot;, function handler(ev) {
                        recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
                        console.log(recbuf.count);
                        if (recbuf.count * recbuf.bufferSize &gt; up.length * 2) {
                            console.log(&quot;done&quot;);
                            processor.removeEventListener(&quot;audioprocess&quot;, handler);
                            processor.disconnect();
                            stream.stop();
                            next();
                        }
                    });
                    function next() {
                        var rawdata = recbuf.merge();
                        var corr = lib.Signal.overwarpCorr(down, rawdata);
                        var render = new duxca.lib.CanvasRender(128, 128);
                        console.log(&quot;raw&quot;, rawdata.length);
                        render.cnv.width = rawdata.length / 256;
                        render.drawSignal(rawdata, true, true);
                        console.screenshot(render.element);
                        console.log(&quot;corr&quot;, corr.length);
                        render.cnv.width = corr.length / 256;
                        render.drawSignal(corr, true, true);
                        console.screenshot(render.element);
                        console.log(&quot;up&quot;, up.length);
                        render.cnv.width = up.length / 256;
                        render.drawSignal(up, true, true);
                        console.screenshot(render.element);
                        render._drawSpectrogram(rawdata, recbuf.sampleRate);
                        console.screenshot(render.cnv);
                    }
                });
            };
            return OSC;
        })();
        lib.OSC = OSC;
    })(lib = duxca.lib || (duxca.lib = {}));
})(duxca || (duxca = {}));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
