<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - output/src/ts/Sandbox6.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>output/src/ts/Sandbox6.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">286</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">83.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.79</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/// &lt;reference path=&quot;../../typings/webrtc/MediaStream.d.ts&quot;/&gt;
/// &lt;reference path=&quot;../../typings/bluebird/bluebird.d.ts&quot;/&gt;
/// &lt;reference path=&quot;../../tsd/console.snapshot/console.snapshot.d.ts&quot;/&gt;
/// &lt;reference path=&quot;../../tsd/MediaStreamAudioSourceNode/MediaStreamAudioSourceNode.d.ts&quot;/&gt;
var duxca;
(function (duxca) {
    var lib;
    (function (lib) {
        var Sandbox;
        (function (Sandbox) {
            navigator.getUserMedia = (navigator.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia);
            function relpos() {
                var K = 0;
                var pseudoPts = [0, 1, 2].map(function (i) { return new lib.Point(Math.random() * 10, Math.random() * 10); });
                var ds = [
                    [0, 1, 1],
                    [1, 0, 1],
                    [1, 1, 0]
                ];
                var sdm = new lib.SDM(pseudoPts, ds);
                (function recur() {
                    if (K++ &lt; 200) {
                        sdm.step();
                        requestAnimationFrame(recur);
                    }
                    else {
                        console.log(&quot;fin&quot;, sdm.det(), sdm.points);
                    }
                }());
            }
            Sandbox.relpos = relpos;
            function testDetect7(rootNodeId) {
                var TEST_INPUT_MYSELF = false;
                var count = 0;
                var actx = new AudioContext();
                var osc = new lib.OSC(actx);
                var isRecording = false;
                var processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1); // between Math.pow(2,8) and Math.pow(2,14).
                var recbuf = new lib.RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);
                var render = new duxca.lib.CanvasRender(128, 128);
                osc.createBarkerCodedChirp(13, 8).then(function (pulse) {
                    render.cnv.width = 1024;
                    render.drawSignal(pulse, true, true);
                    console.log(&quot;length&quot;, pulse.length, &quot;sec&quot;, pulse.length / actx.sampleRate);
                    console.screenshot(render.element);
                    return pulse;
                }).then(function (pulse) {
                    var chord = new duxca.lib.Chord();
                    chord.debug = false;
                    chord.on(&quot;ping&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        cb(token);
                    });
                    chord.on(&quot;recStart&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        isRecording = true;
                        cb(token);
                    });
                    var pulseStartTime = {};
                    chord.on(&quot;pulseStart&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        var id = token.payload.data;
                        pulseStartTime[id] = actx.currentTime;
                        cb(token);
                    });
                    var abuf = osc.createAudioBufferFromArrayBuffer(pulse, actx.sampleRate);
                    chord.on(&quot;pulseBeep&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        var id = token.payload.data;
                        if (chord.peer.id !== id)
                            return cb(token);
                        var anode = osc.createAudioNodeFromAudioBuffer(abuf);
                        anode.connect(TEST_INPUT_MYSELF ? processor : actx.destination);
                        anode.start(actx.currentTime);
                        setTimeout(function () { return cb(token); }, pulse.length / actx.sampleRate * 1000);
                    });
                    var pulseStopTime = {};
                    chord.on(&quot;pulseStop&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        var id = token.payload.data;
                        pulseStopTime[id] = actx.currentTime;
                        cb(token);
                    });
                    var pulseTime = null;
                    chord.on(&quot;recStop&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        var tmp = recbuf.count;
                        (function recur() {
                            if (recbuf.count === tmp)
                                return setTimeout(recur, 100); // wait audioprocess
                            isRecording = false;
                            pulseTime = null;
                            setTimeout(function () {
                                pulseTime = calc(chord.peer.id, pulse, pulseStartTime, pulseStopTime);
                            }, 0);
                            cb(token);
                        })();
                    });
                    chord.on(&quot;collect&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        (function recur() {
                            if (pulseTime === null)
                                return setTimeout(recur, 100); // wait calc
                            token.payload.data[chord.peer.id] = pulseTime;
                            cb(token);
                        })();
                    });
                    var pulseTimes = null;
                    var relDelayTimes = null;
                    var delayTimesLog = {};
                    chord.on(&quot;distribute&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        pulseTimes = token.payload.data;
                        relDelayTimes = {};
                        Object.keys(pulseTimes).forEach(function (id1) {
                            Object.keys(pulseTime).forEach(function (id2) {
                                relDelayTimes[id1] = relDelayTimes[id1] || {};
                                relDelayTimes[id1][id2] = pulseTimes[id1][id2] - pulseTimes[id1][id1];
                            });
                        });
                        console.log(&quot;relDelayTimes&quot;, relDelayTimes);
                        Object.keys(pulseTimes).forEach(function (id1) {
                            delayTimesLog[id1] = delayTimesLog[id1] || {};
                            Object.keys(pulseTime).forEach(function (id2) {
                                delayTimesLog[id2] = delayTimesLog[id2] || {};
                                if (!Array.isArray(delayTimesLog[id1][id2]))
                                    delayTimesLog[id1][id2] = [];
                                if (delayTimesLog[id1][id2].length &gt; 10)
                                    delayTimesLog[id1][id2].shift();
                                var delayTime = Math.abs(Math.abs(relDelayTimes[id1][id2]) - Math.abs(relDelayTimes[id2][id1]));
                                delayTimesLog[id1][id2].push(delayTime);
                                console.log(&quot;__RES__&quot;, id1, id2, &quot;delayTime&quot;, delayTime, &quot;distance&quot;, delayTime / 2 * 340, &quot;ave&quot;, duxca.lib.Statictics.average(delayTimesLog[id1][id2]), &quot;mode&quot;, duxca.lib.Statictics.mode(delayTimesLog[id1][id2]), &quot;med&quot;, duxca.lib.Statictics.median(delayTimesLog[id1][id2]), &quot;stdev&quot;, duxca.lib.Statictics.stdev(delayTimesLog[id1][id2]));
                            });
                        });
                        cb(token);
                    });
                    chord.on(&quot;play&quot;, function (token, cb) {
                        console.log(token.payload.event, token.payload.data);
                        var wait = token.payload.data;
                        var id1 = token.route[0];
                        var id2 = chord.peer.id;
                        var delay = duxca.lib.Statictics.median(delayTimesLog[id1][id2]);
                        var offsetTime = pulseTimes[id2][id1] + wait + delay;
                        console.log(id1, id2, &quot;delay&quot;, delay, wait, offsetTime, pulseTimes, delayTimesLog);
                        osc.createAudioBufferFromURL(&quot;./TellYourWorld1min.mp3&quot;).then(function (abuf) {
                            var node = osc.createAudioNodeFromAudioBuffer(abuf);
                            node.start(offsetTime);
                            node.loop = true;
                            node.connect(actx.destination);
                        });
                        cb(token);
                    });
                    return (typeof rootNodeId === &quot;string&quot;) ? chord.join(rootNodeId) : chord.create();
                }).then(function (chord) {
                    console.log(chord.peer.id);
                    return new Promise(function (resolbe, reject) { return navigator.getUserMedia({ video: false, audio: true }, resolbe, reject); })
                        .then(function (stream) {
                        var source = actx.createMediaStreamSource(stream);
                        !TEST_INPUT_MYSELF &amp;&amp; source.connect(processor);
                        processor.connect(actx.destination);
                        processor.addEventListener(&quot;audioprocess&quot;, function handler(ev) {
                            if (isRecording)
                                recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
                        });
                        return new Promise(function (resolve, reject) {
                            setTimeout(function () {
                                resolve(Promise.resolve(chord));
                            }, 1000);
                        });
                    }).then(function () { return chord; });
                }).then(typeof rootNodeId === &quot;string&quot; ? function (chord) { return void 0; } : function recur(chord) {
                    chord.request(&quot;ping&quot;)
                        .then(function (token) { return chord.request(&quot;recStart&quot;, null, token.route); })
                        .then(function (token) {
                        return token.payload.addressee.reduce(function (prm, id) {
                            return prm
                                .then(function (token) { return chord.request(&quot;pulseStart&quot;, id, token.payload.addressee); })
                                .then(function (token) { return chord.request(&quot;pulseBeep&quot;, id, token.payload.addressee); })
                                .then(function (token) { return chord.request(&quot;pulseStop&quot;, id, token.payload.addressee); });
                        }, Promise.resolve(token));
                    })
                        .then(function (token) { return chord.request(&quot;recStop&quot;, null, token.payload.addressee); })
                        .then(function (token) { return chord.request(&quot;collect&quot;, {}, token.payload.addressee); })
                        .then(function (token) { return chord.request(&quot;distribute&quot;, token.payload.data, token.payload.addressee); })
                        .then(function (token) {
                        console.log(count, Date.now());
                        if (++count === 2) {
                            chord.request(&quot;play&quot;, (Date.now() - token.time[0]) * 1.5 / 1000 + 1, token.payload.addressee).then(function (token) {
                                //setTimeout(recur.bind(null, chord), 0);
                            });
                        }
                        else
                            setTimeout(recur.bind(null, chord), 0);
                    });
                    return chord;
                });
                function calc(myId, pulse, pulseStartTime, pulseStopTime) {
                    var rawdata = recbuf.merge();
                    var sampleTimes = recbuf.sampleTimes;
                    recbuf.clear();
                    var recStartTime = sampleTimes[0] - (recbuf.bufferSize / recbuf.sampleRate);
                    var recStopTime = sampleTimes[sampleTimes.length - 1];
                    var pulseTime = {};
                    var pulseOffset = {};
                    Object.keys(pulseStartTime).forEach(function (id) {
                        var startTime = pulseStartTime[id];
                        var stopTime = pulseStopTime[id];
                        var startPtr = (startTime - recStartTime) * recbuf.sampleRate;
                        var stopPtr = (stopTime - recStartTime) * recbuf.sampleRate;
                        var section = rawdata.subarray(startPtr, stopPtr);
                        var corrsec = lib.Signal.smartCorrelation(pulse, section);
                        console.log(corrsec.length, pulse.length, section.length);
                        console.log(id, &quot;recStartTime&quot;, recStartTime, &quot;recStopTime&quot;, recStopTime, &quot;startTime&quot;, startTime, &quot;stopTime&quot;, stopTime, &quot;startPtr&quot;, startPtr, &quot;stopPtr&quot;, stopPtr, &quot;length&quot;, section.length);
                        var _a = duxca.lib.Statictics.findMax(corrsec), max_score = _a[0], max_offset = _a[1];
                        var offset = -1;
                        for (var i = 0; i &lt; corrsec.length; i++) {
                            if (max_score / 2 &lt; corrsec[i]) {
                                offset = i;
                                pulseOffset[id] = startPtr + i;
                                pulseTime[id] = (startPtr + i) / recbuf.sampleRate;
                                break;
                            }
                        }
                        console.log(id, &quot;offset&quot;, offset, &quot;max_offset&quot;, max_offset, &quot;max_score&quot;, max_score, &quot;globalOffset&quot;, startPtr + offset);
                        render.cnv.width = 1024;
                        render.cnv.height = 32;
                        render.ctx.strokeStyle = &quot;black&quot;;
                        render.drawSignal(corrsec, true, true);
                        render.ctx.strokeStyle = &quot;blue&quot;;
                        render.drawColLine(offset * 1024 / corrsec.length);
                        render.ctx.strokeStyle = &quot;red&quot;;
                        render.drawColLine(max_offset * 1024 / corrsec.length);
                        console.log(id, &quot;corrsec&quot;);
                        console.screenshot(render.cnv);
                    });
                    var render1 = new duxca.lib.CanvasRender(1024, 32);
                    var render2 = new duxca.lib.CanvasRender(1024, 32);
                    var render3 = new duxca.lib.CanvasRender(1024, 32);
                    render2.drawSignal(rawdata, true, true);
                    var sim = new Float32Array(rawdata.length);
                    Object.keys(pulseOffset).forEach(function (id) {
                        if (sim.length &lt; pulseOffset[id] + pulse.length) {
                            sim.set(pulse.subarray(0, (pulseOffset[id] + pulse.length) - sim.length), pulseTime[id]);
                        }
                        else
                            sim.set(pulse, pulseOffset[id]);
                    });
                    render3.drawSignal(sim, true, true);
                    var correlation = duxca.lib.Signal.smartCorrelation(pulse, rawdata);
                    console.log(correlation.length, pulse.length, rawdata.length);
                    Object.keys(pulseOffset).forEach(function (id) {
                        var startTime = pulseStartTime[id];
                        var stopTime = pulseStopTime[id];
                        var startPtr = (startTime - recStartTime) * recbuf.sampleRate;
                        var stopPtr = (stopTime - recStartTime) * recbuf.sampleRate;
                        render1.ctx.strokeStyle = &quot;blue&quot;;
                        render2.ctx.strokeStyle = &quot;blue&quot;;
                        render3.ctx.strokeStyle = &quot;blue&quot;;
                        render1.drawColLine(startPtr * 1024 / correlation.length);
                        render1.drawColLine(stopPtr * 1024 / correlation.length);
                        render2.drawColLine(startPtr * 1024 / rawdata.length);
                        render2.drawColLine(stopPtr * 1024 / rawdata.length);
                        render3.drawColLine(startPtr * 1024 / sim.length);
                        render3.drawColLine(stopPtr * 1024 / sim.length);
                        render1.ctx.strokeStyle = &quot;red&quot;;
                        render2.ctx.strokeStyle = &quot;red&quot;;
                        render3.ctx.strokeStyle = &quot;red&quot;;
                        render1.drawColLine(pulseOffset[id] * 1024 / correlation.length);
                        render2.drawColLine(pulseOffset[id] * 1024 / rawdata.length);
                        render3.drawColLine(pulseOffset[id] * 1024 / sim.length);
                    });
                    console.log(&quot;correlation&quot;);
                    console.screenshot(render1.cnv);
                    console.log(&quot;rawdata&quot;);
                    console.screenshot(render2.cnv);
                    console.log(&quot;sim&quot;);
                    console.screenshot(render3.cnv);
                    console.log(&quot;pulseOffset&quot;, pulseOffset);
                    console.log(&quot;pulseTime&quot;, pulseTime);
                    render._drawSpectrogram(rawdata, recbuf.sampleRate);
                    console.screenshot(render.cnv);
                    return pulseTime;
                }
            }
            Sandbox.testDetect7 = testDetect7;
        })(Sandbox = lib.Sandbox || (lib.Sandbox = {}));
    })(lib = duxca.lib || (duxca.lib = {}));
})(duxca || (duxca = {}));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
