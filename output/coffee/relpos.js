// Generated by CoffeeScript 1.9.3
(function() {
  var Newton, Point, SDM, arc, cross, main;

  main = function() {
    var height, i, realPts, setup, width;
    width = height = 300;
    realPts = (function() {
      var l, results;
      results = [];
      for (i = l = 1; l <= 10; i = ++l) {
        results.push(new Point(Math.random() * width, Math.random() * height));
      }
      return results;
    })();
    return (setup = function() {
      var K, _, cnv, ctx, draw, ds, j, l, len, len1, m, pseudoPts, sdm;
      cnv = document.createElement("canvas");
      cnv.width = cnv.height = width;
      document.body.appendChild(cnv);
      ctx = cnv.getContext("2d");
      pseudoPts = (function() {
        var l, len, results;
        results = [];
        for (l = 0, len = realPts.length; l < len; l++) {
          i = realPts[l];
          results.push(new Point(Math.random() * width, Math.random() * height));
        }
        return results;
      })();
      ds = [];
      for (i = l = 0, len = realPts.length; l < len; i = ++l) {
        _ = realPts[i];
        ds[i] = [];
        for (j = m = 0, len1 = realPts.length; m < len1; j = ++m) {
          _ = realPts[j];
          ds[i][j] = realPts[i].distance(realPts[j]);
        }
      }
      sdm = new SDM(pseudoPts, ds);
      K = 0;
      return (draw = function() {
        var len2, len3, n, o, offsetX, offsetY, pt, ref, ref1;
        if (K++ < 200) {
          cnv.width = cnv.width;
          sdm.step();
          ctx.strokeStyle = "red";
          for (n = 0, len2 = realPts.length; n < len2; n++) {
            pt = realPts[n];
            arc(cnv, ctx, pt.x, pt.y);
          }
          ctx.strokeStyle = "blue";
          ref = realPts[0].minus(sdm.pts[0]), offsetX = ref.x, offsetY = ref.y;
          ref1 = sdm.pts;
          for (o = 0, len3 = ref1.length; o < len3; o++) {
            pt = ref1[o];
            cross(cnv, ctx, pt.x + offsetX, pt.y + offsetY);
          }
          return requestAnimationFrame(draw);
        } else {
          ctx.fillStyle = "black";
          ctx.fillText(sdm.det(), 8, 18);
          return requestAnimationFrame(setup);

          /*
          L = 0
          {x:offsetX, y:offsetY} = realPts[0].minus(sdm.pts[0])
          _pts = (new Point(pt.x+offsetX, pt.y+offsetY) for pt in sdm.pts)
          nwt = new Newton(0, realPts, _pts)
          do draw2 = ->
            if L++ < 100
              cnv.width = cnv.width
              nwt.step()
              ctx.strokeStyle = "red"
              for pt in realPts
                arc(cnv, ctx, pt.x, pt.y)
              ctx.strokeStyle = "blue"
              for pt in _pts
                x = pt.x*Math.cos(nwt.theta)-pt.y*Math.sin(nwt.theta)
                y = pt.x*Math.sin(nwt.theta)+pt.y*Math.cos(nwt.theta)
                cross(cnv, ctx, x, y)
              requestAnimationFrame(draw2)
            else
              ctx.fillStyle = "black"
              ctx.fillText(sdm.det(), 18, 18)
              requestAnimationFrame(setup)
           */
        }
      })();
    })();
  };

  SDM = (function() {
    function SDM(pts, ds1, a) {
      this.pts = pts;
      this.ds = ds1;
      this.a = a != null ? a : 0.05;
    }

    SDM.prototype.step = function() {
      var _, _pts, delta, i, l, len, ref;
      _pts = [];
      console.clear();
      ref = this.pts;
      for (i = l = 0, len = ref.length; l < len; i = ++l) {
        _ = ref[i];
        delta = this.ds[i].reduce(((function(_this) {
          return function(sumPt, _, j) {
            if (i === j) {
              return sumPt;
            } else {
              return sumPt.plus((_this.pts[i].minus(_this.pts[j])).times(1 - _this.ds[i][j] / _this.pts[i].distance(_this.pts[j])));
            }
          };
        })(this)), new Point(0, 0)).times(2);
        _pts[i] = this.pts[i].minus(delta.times(this.a));
      }
      return this.pts = _pts;
    };

    SDM.prototype.det = function() {
      return this.pts.reduce(((function(_this) {
        return function(sum, _, i) {
          return sum + _this.pts.reduce((function(sum, _, j) {
            if (i === j) {
              return sum;
            } else {
              return sum + Math.pow(_this.pts[i].distance(_this.pts[j]) - _this.ds[i][j], 2);
            }
          }), 0);
        };
      })(this)), 0);
    };

    return SDM;

  })();

  Newton = (function() {
    function Newton(theta1, pts, _pts1) {
      this.theta = theta1;
      this.pts = pts;
      this._pts = _pts1;
    }

    Newton.prototype.step = function() {
      var _theta;
      _theta = this.theta - this.det(this.theta) / this.der(this.theta);
      return this.theta = _theta;
    };

    Newton.prototype.det = function(theta) {
      return this.pts.reduce((function(_this) {
        return function(sum, _, k) {
          return (_this.pts[k].x - Math.pow(_this._pts[k].x * Math.cos(theta) - _this._pts[k].y * Math.sin(theta), 2)) + (_this.pts[k].y - Math.pow(_this._pts[k].x * Math.sin(theta) + _this._pts[k].y * Math.cos(theta), 2));
        };
      })(this));
    };

    Newton.prototype.der = function(theta) {
      return -2 * this.pts.reduce((function(_this) {
        return function(sum, _, k) {
          return (_this.pts[k].x * (-1 * _this._pts[k].x * Math.sin(theta) - _this._pts[k].y * Math.cos(theta))) + (_this.pts[k].y * (-1 * _this._pts[k].x * Math.cos(theta) - _this._pts[k].y * Math.sin(theta)));
        };
      })(this));
    };

    return Newton;

  })();

  Point = (function() {
    function Point(x1, y1) {
      this.x = x1;
      this.y = y1;
    }

    Point.prototype.plus = function(pt) {
      return new Point(this.x + pt.x, this.y + pt.y);
    };

    Point.prototype.minus = function(pt) {
      return new Point(this.x - pt.x, this.y - pt.y);
    };

    Point.prototype.times = function(num) {
      return new Point(num * this.x, num * this.y);
    };

    Point.prototype.distance = function(pt) {
      return Math.sqrt(Math.pow(pt.x - this.x, 2) + Math.pow(pt.y - this.y, 2));
    };

    return Point;

  })();

  cross = function(cnv, ctx, x, y) {
    ctx.beginPath();
    ctx.moveTo(x + 4, y + 4);
    ctx.lineTo(x - 4, y - 4);
    ctx.moveTo(x - 4, y + 4);
    ctx.lineTo(x + 4, y - 4);
    return ctx.stroke();
  };

  arc = function(cnv, ctx, x, y) {
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, 2 * Math.PI, false);
    return ctx.stroke();
  };

  console.clear();

  main();

}).call(this);
